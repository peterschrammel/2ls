0> How do we compute abstract forward transformers on the SSA generated from summarizer
1> ssa_fixed_point.cpp inside domain is used to perform the forward and backward propagation to derive the 
   strongest post-condition and weakest pre-condition. This is equivalent to the BCP step of the SAT solver. The purpose is to compute 
   the obvious facts by propagation until a greatest fixed point is reached.

2> Why the divider circuit fails in summarizer. The assertion is simple. What options to run for this ? 

3> Do we follow the CDCL path for implementation or do we follow the AI path for implementation ? For ACDCL, the high level 
phases are BCP, decision, conflict, learn, backtrack. 

4> One abstract state per program location -- hoe does it handle things like relational ?
5> For loops, have both option: -- do unwinding and also do join.
6> Use octagons from Apron library? Does Apron library does not have backward transformer implementation.

7> SSA generation:
#include <limits.h>

void main() {
  int x,y,z;
  _Bool c;
      
  // abstract domain for booleans no implemented inside cdfpl
  // decisions on booleans has to be made
  if (c)
   x = -1;
  else
   x = 2; 
  // x = [-1,2]  
  z = x * x; // z = [0,4]
  assert((z!=2));
}

SUMMARIZER version 0.1.0 (based on CBMC 5.1)
Parsing filter.c
Converting
Type-checking filter
Generating GOTO Program
Adding CPROVER library
Generic Property Instrumentation
Function Pointer Removal
>>>> Function main
*** 0 file filter.c line 4 function main
(not marked)
(E) $guard#0 == TRUE

*** 4 file filter.c line 9 function main
(not marked)
(E) $cond#4 == (c#3 == FALSE)

*** 5 file filter.c line 10 function main
(not marked)
(E) x#5 == -1
(E) $guard#5 == (!$cond#4 && $guard#0)

*** 6 file filter.c line 10 function main
(not marked)
(E) $cond#6 == TRUE

*** 7 file filter.c line 12 function main
(not marked)
(E) x#7 == 2
(E) $guard#7 == ($cond#4 && $guard#0)

*** 8 file filter.c line 14 function main
(not marked)
(E) z#8 == x#phi8 * x#phi8
(E) x#phi8 == ($cond#6 && $guard#5 ? x#5 : x#7)
(E) $guard#8 == ($cond#6 && $guard#5 || $guard#7)

*** 9 file filter.c line 15 function main
(not marked)
(A) !$guard#8 || z#8 != 2

(enable) TRUE


>>>> Function _start
*** 15 
(not marked)
(E) $cond#15 == TRUE
(E) $guard#15 == TRUE
(F) __CPROVER_initialize()

*** 16 file filter.c line 3
(not marked)
(E) $cond#16 == TRUE
(E) $guard#16 == ($cond#15 && $guard#15)
(F) main()

*** 17 
(not marked)
(E) $guard#17 == ($cond#16 && $guard#16)

(enable) TRUE


>>>> Function __CPROVER_initialize
*** 18 
(not marked)
(E) $guard#18 == TRUE

*** 19 file <built-in-additions> line 31
(not marked)
(E) __CPROVER_dead_object#19 == NULL

*** 20 file <built-in-additions> line 32
(not marked)
(E) __CPROVER_malloc_object#20 == NULL

*** 21 file <built-in-additions> line 33
(not marked)
(E) __CPROVER_malloc_size#21 == 0ul

*** 22 file <built-in-additions> line 34
(not marked)
(E) __CPROVER_malloc_is_new_array#22 == FALSE

*** 23 file <built-in-additions> line 35
(not marked)
(E) __CPROVER_memory_leak#23 == NULL

*** 24 file <built-in-additions> line 21
(not marked)
(E) __CPROVER_thread_id#24 == 0ul

*** 25 file <built-in-additions> line 57
(not marked)
(E) __CPROVER_rounding_mode#25 == 0

*** 26 file <built-in-additions> line 22
(not marked)
(E) __CPROVER_threads_exited#26 == ARRAY_OF(FALSE)

*** 27 file <built-in-additions> line 23
(not marked)
(E) __CPROVER_next_thread_id#27 == 0ul

*** 28 file <built-in-additions> line 79
(not marked)
(E) __CPROVER_pipe_count#28 == 0u

*** 29 file <built-in-additions> line 30
(not marked)
(E) __CPROVER_deallocated#29 == NULL

(enable) TRUE

Peter+Bjorn Discussion, 3rd July 2015
--------------------------------------
1) ACDL starts with TOP in the beginning and has BOTTOM at all other cfg nodes. It computes the gfp. ACDL only computes the forward abstract transformers
2) Astree starts with BOTTOM in the beginning and at all other cfg nodes. It computes the lfp. It doesnot compute the backward transformers.


Note of the summarizer code
-----------------------------
1) class nodet is the SSA node for a location.

***** Discussion with Peter on 18th Nov, 2015 *****
*) --show-ssa with summarizer show different variable index (x#20) compared to running with --acdl 
and printing the variables inside acdl code. To resolve this, run acdl as follows:
./summarizer --inline --acdl main.c
*) Peter to merge summarizer code base with main trunk so that our branch is automatically updated.
*) Inside acdl_domain, implement is_top, is_bottom, is_complete
*) Inside acdl_solver, implement the whole acdl loop. Implement the decision, conflict analysis steps.
For decision see reference of leo's VSIDS heuristic. 

*) For pre-condition computation, the trick is to perform two way propagation. Project lhs on rhs and project rhs on lhs.
*) For bottom3 example, * and / does not work. Although + and - work correctly. i

// Daniel's suggestion to handle branches in SSA representation
Look at guards (guard variables in SSA) and make a decision on guards. 
Use the boolean part of guard to decide using MiniSAT and the non-boolean part of the guard to decide with 
abstract domains (intervals). What a decision variable would be in ACDL solver is not known yet !

*) For example where x=1; assert(x==2); is unknown. Because while calculating the projection and 
computing the new value, (x!=2) can not be expressed by interval domain !!

*) Computing the update worklist seems to be a problem. All dependencies are not pushed properly now.

*) We now use summarizer/2ls as executable to run acdl. To see the ssa representation, we now do --show-ssa --no-propagation
../../../src/summarizer/2ls --acdl main.c --show-ssa --no-propagation

*) We plan to build acdl with complete solver support now and no hardcore abstract domain implementation. The major difference 
between acdl and summarize is that acdl follow small step semantics of the program unlike large block encoding in summarizer.

Discussion with Peter
---------------------
1> We do multi-way propagation of abstract values for all nodes in SSA, that is, 
equalities, assertions and constraints. 

Queries:
--------
bottom3 is absolutely fine
bottom5 is showing unknown when it should show true: What happens when somethings holds ture  ?

Some observations:
------------------
1> Consider the following program:
int main() {
  int x, y;

  x = 8;
  y = x;
  assert(y!=15);
}
CBMC with MiniSAT(CDCL solver), cdfpl and acdl -- none of these algorithms made a single decision 
to infer that the program is safe. Only deductions are performed to ensure that the program is safe.

2> Consider the following program:
int main() {
  int x, y;

  x = 1;
  y = x + 3;
  x = y - 2;

  assert(x!=2);
}

***********************************************************
CBMC with MiniSAT(CDCL solver): --> This made one decision
***********************************************************
Solving with MiniSAT 2.2.0 with simplifier
72 variables, 11 clauses
SAT checker: negated claim is SATISFIABLE, i.e., does not hold
restarts              : 1
conflicts             : 0           
decisions             : 1           
propagations          : 4           
conflict literals     : 0           
Runtime decision procedure: 0s
Building error trace

***********************************************************
Leo's AI --> This made 66 decisions 
***********************************************************
ITERATION (decision) 66
================ 
{ c::$file::main::1::x in INT: [-2147483648, -2147483648], c::$file::main::1::y in INT: [-2147483648, -2147483648] }
new dlevel: 67
scores: -1 -1 
FAILED TO VERIFY PROGRAM
Minimal unsafe element: { c::$file::main::1::x in INT: [-2147483648, -2147483648], c::$file::main::1::y in INT: [-2147483648, -2147483648] }== Procedure terminated after 67 iterations 


**** Verification failed 
Found 1 possible assertion violations
********
5: ASSERT  x != 2
    GOTO 6
    Potential violation: x == 2 && y == 4

    Information over assertion variables: x == 2 

***********************************************************
ACDL with SSA
***********************************************************
Updated: x#19 <= 1 && x#21 <= 2 && x#21 <= 2147483647 && y#20 <= 4 && y#20 <= 2147483647 && -((signed __CPROVER_bitvector[33])x#19) <= -1 && -((signed __CPROVER_bitvector[33])x#21) <= 2147483648 && -((signed __CPROVER_bitvector[33])x#21) <= -2 && -((signed __CPROVER_bitvector[33])y#20) <= 2147483648 && -((signed __CPROVER_bitvector[33])y#20) <= -4 && $guard#0 == TRUE && $guard#0
Propagation finished with UNKNOWN
Note that the above constraints means the following: (x_19 = [1,1]) && (x_21 = [2,2]) && (x_21 = [-2^32, 2^32-1]) && (y_20 == [4,4]) && (y_20 == [-2^32, 2^32 - 1]) -- This is the abstract state now. No further deduction can be made now. 

My point: Now, if we decide on latest value of x which is x_21 = [-2^32, 0] (property-guided decision), then do propagation again, then what happens ? 
The way we can reach BOTTOM immediately when taking a meet of the decision with the present abstract state (shown above) leads to prving unsafety in one decision. 
Compared to AI, do we need 66 iterations to decide the unsafety of the program. Do we throw away existing abstract state when we make a new decision ? 
Do we propagate a new decision from the starting node again? 

Meeting with Peter on 9th Dec, 2015
------------------------------------
1> We implemented gamma-completeness check to see if the abstract state where 
every variable has a singleton value indeed is a concrete counterexample. 
The gamma completeness check is done when deduction is finished (worklist is empty), 
and every variable in the abstract state has a concrete assignment, we then check if the
these assignments are indeed a valid counterexample. To do so, we first take the abstract 
state and for each variable in the abstract state we negate the constraints associated with
it (eg, !(x == 2)) and decide with the solver whether the conjunction of the abstract state
with the negated clause involving the variable is UNSAT. If it is UNSAT, then it is a real 
counterexample. 

2> Peter To do: normalization of the abstract state while computing meet. 
For example, (x == [-2^32, 2^32-1]) && (x == [3,3]) --> normalize this to --> (x = [3,3])

3> Decision strategy: We decide on a variable using some heuristics and then split the bound 
of this variable to form a decision expression. Take the meet of the decision expression 
with the abstract state to derive a new abstract state. 

Queries:
*> For if-else program in regression, the following is shown by acdl.
prop_convt::convert_bool got non-boolean expression:
("constant" "type" ("signedbv" "width" ("32") "#c_type" ("signed_int")) "value" ("00000000000000000000000000000000") "#source_location" ("" "file" ("main.c") "line" ("4") "function" ("main")) "#cformat" ("0"))
 
*> Do I need to pass the expression template like (x-y) or (x) or (x>0) to the split function  

*) Since bottom2 has assertion (x==2) which is non-convex, so when is the decision made for this program. Is it 
in the beginning or after gamma-completeness.

*) How to check meet irreducible -- implement this. 

Meeting with Peter on 11th Dec, 2015
-------------------------------------
*> The guard variable in SSA is determined by the cond variable (for programs without loops). So, 
when cond==1, it implies guard==1.

*> SAT solver calls in our case is part of the abstract domain  

*> decision_graph contains the following information:
   edges: if the first decisions is (y<0), second decision is (x>0), then 
   there is an edge like this. x>0 ----> y<0 ----> nil_exprt() // Note that root is always nil_exprt()
   backtrack_points: this is map which contains decisions as index and abstract values at each decision points,
                     for example, backtrack_points[decision] = v; // where v is the abstract value 
   Our assumption is that the decisions are usually unique. That is, if (x<0) is decided once, then it will not be 
   decided in future. 

*> split function in the acdl_domain returns meet irreducibles. 
   For example, if (x!=2) it returns (x <= 1) V (x>=3)

Query:
1> Can we avoid pushing statements like y#18 == nondet_symbol(ssa::nondet18.1) ?
2> Check if the edge update implementation inside the decision is correct or not ?
3> If I have multiple if-else branch, which cond to decide on. Now the last cond is always taken.
4> If cond == (x==4), then !cond == (x!=4) which cannot be represented in the domain now
5> Do I need to empty the worklist before updating the worklist in conflict analysis phase ?
6> For the present error, either we take separate care for updating worklist for cond variables or 
the boolean case in acdl domain is wrong because the if-else were properly working without product domain.

Meeting on 14th December, 2015
---------------------------------
1> Updating worklist for conditionals seems to be a problem.
Conside the following case:
  Statement            Abstract value
  ---------           ----------------
guard0 = true            guard0=true
guard1 = guard0&&cond    guard0=true // no information available about cond which means that they are TOP
cond = (x<10)           
 x = 5
For the above situation, we need to look ahead upto x=5 and then compute the abstract value of guard1 
to mimic the deduction phase of the SAT solver. The deduction phase must guarantee that all informations
that is obvious must be computed, meaning gfp iteration in AI. 

Consider another situation:
  Statement            Abstract value
  ---------           ----------------
guard0 = true           guard0=true
guard1 = guar0&&cond    guard0=true // no information available about cond and guard which means that they are TOP
 cond = (x<10)
 x = h, h is symbolic                 
 y = g, g is symbolic

 
Meeting on 15th December, 2015
-------------------------------
1> Update worklist algorithm:
Intialize the worklist with the assertions at the beginning:
Let a1, a2, a3 be three assertions. Then, the worklist first 
stores (!(a1 && a2 && a3)). Compared to our last implementation, 
where we always store all the statement in the worklist that is 
dependent on the variables present in the current statement, in 
our new implementation, we need to store all transitive dependencies 
in the worklist as well. For this, we need to create a graph where
for each variables, we need to cache its corresponding transitive 
dependencies so that when the same variable arise next time, we 
do not have to track the whole dependencies for that variable again and 
  simply look at the graph. The contains check in the worklist still 
  remains the same for terminating condition. The graph must return 
  set of all statements which are dependant on the current selected 
  variable.
  
2> For Learning, look at Leo's first UIP algorithm and the data 
structure used there. Make a separate class for conflict_analysis.
The decision_grapht must have some mechanism to store the deduction 
as well as this is also needed in the first UIP algorithm.

3> Implement the decision heuristic, where decisions are taken on 
cond and assertion variables with meet irreducibles, like (x!=5) gives
us (-2^32,4) meet (6, 2^32-1)
 
   
Meeting on 16th December, 2015
-------------------------------
1> Insert into worklist in the following order:

Assert -------> top
Leaf   -------> Middle
Rest   -------> Bottom

2> Then while in deduction phase, when popping an element, process the element and then 
insert the same element in the end of the worklist.

Meeting on 8th January, 2016
-------------------------------
1> The decision_grapht must have some mechanism to store the deduction 
as well as this is also needed in the first UIP algorithm. How to store this ?
Show the code of updating the deduction list inside decision and the header file. 
Also, do we need to pass the decision graph as parameter to the propagate routine 
because that is where the new abastact value is computed ?

2> Then while in deduction phase, when popping an element, process the element and then 
insert the same element in the end of the worklist. If we do not do this step, will the
 analysis be unsound. 

3> Conflict analysis must return PASS if the learnt clause leads to proving the safety, 
else it always returns UNKNOWN.

4> branch3 did not terminate while branch2 terminated (similar program)

5> Run through all conditional variables, and pick up the first one where
decision is not done yet (split does not return false). This continues until 
split returns false for all conditional variables which means that the decision 
has been on all conditional variables and there are no conditional variables 
needed. If that is the case, then return to the meta heuristics to decide on 
numerical variables (say). — implement this in decision_heuristic_conditional
 
6> Gama completeness check is too restrictive — now works on singletons 
 
 
  
Meeting on 12th January, 2016
-------------------------------
For every propagation, we need to keep track of the variable which has been assigned a value 

A trail is a sequentialised version of the implication graph 
One decision — one propagation 
Implication graph is a more structured form of trail and contains additional information of causality (implications) — 
trail and implication graph — separate implementation
Nodes in an implication graph are either decisions or inferences 
Flags to determine whether a node is a decision or a inference 
The nodes of the implication graph are meet irreducibles 
The domain operator must return list of meet irreducibles that have been 
inferred 
Implement a clean implication graph — constraint in the nodes, each node 
are meet irreducibles (implication graph is independent of abstract domain).
Present decision level and list of implications — get a list of new nodes and 
for each new node, I have a list of parent nodes — only semantic information is parent node implies this new node, meet irreducible linked to the new node, 
  add a decision (meet irreducible of the decision) —
  Two methods 
  1> adding decision — just takes meet irreducible and increment decision level
  2> add an implication — list of parent nodes, and new node (meet irreducibles associated with it)
  3> add decision level at which to backtrack

Question 1>  We need to determine the update of meet irreducibles  — for pushing the elements which has been popped from the wordlist

Meeting on 15th January, 2016
-------------------------------
1> Create a separate class for implication graph and separate class for conflict analysis 


Meeting on 5th February, 2016
-------------------------------
1> The implementation of implication graph and domain computation for deduction
should be separate
2> The nodes in the implication graph are meet irreducibles.
Let the current partial assignment be: {x>=0, x<=10, y>=5, y<=8}, all are meet
irreducibles
Let the statement be: x'=x+y
Then, abstract value returned by the domain is: (x' >= 5, x' <= 18), which is a
meet irreducible
Now, the deduction information is computed as follows:
{x >= 0, y >= 5} --> (x' >= 5), here {x>=0, y>=5} is the antecedent or the child
nodes in the implication graph which points to (x' >= 5) 
{x <= 10, y <= 8} --> (x' <= 18), here {x<=10, y<=8} is the antecedent or the child
nodes in the implication graph which points to (x' <= 18)

In particular, we look for which meet irreducibles are responsible for
deducing which other meet irreducibles, these meet irreducibles are added 
are added as nodes in the implication graph. We need to infer this information 
from the SAT solver.

3> Interface to the implication graph: 
   a> add deduction 
   b> add decision 
   c> backtrack to level (index)
   
4> Conflict clauses are always added as a "conditional" to the SSA and not as 
"assignments". Like in SAT solver where conflict clauses are added in the 
clause database, we need to maintain a separate list of conflict clauses 
that are discovered. Later, we need to add these conflict clauses as 
set of SSA's (ultimately added to the worklist) so that they 
partiticipate in the subsequent deduction phase. Does conflict 
clause always have to be unit clause after backtracking because 
literals in conflict clause are flipped to reverse the decision ? 
 
Meeting with Marcelo on 5th February, 2016
-------------------------------------------
1> ACDL is a forward cheap analysis which computes strongest post-condition 
with backward expensive analysis which computes weakest pre-condition. 

2> How do ACDL different from SMT solvers. In SMT, decisions and learning
happens in a theory solver. In ACDL, decision and learning happens in a 
domain. Domains in ACDL correspond to theory in SMT. But ACDL performs 
fix-point theory learning in the conflict analysis phase. 

TODO:
IMPORTANT POINT:
----------------
1> When propagation finish with BOTTOM, empty the worklist and empty the live
variables. Becuase the present decision lead to BOTTOM, so whatever is in the 
worklist, everything is invalid and need to be thrown out before we enter into 
the conflict analysis phase. Remember that we guarantee before entering into
decision phase, that is the last propagation step before decision, the worklist 
is empty and live variables are empty. Further, when the propagation finish with 
BOTTOM, the conflict analysis phase must only start with the learnt clause in
the worklist and live variables being empty.

2> nondet  symbols during worklist update is pushed now. Don’t push nondet
elements when updating worklist.

3> cond = (x <= 0), when a decision is made on cond, then all elements dependent
on cond is pushed. 
But in addition to that, all statements dependent on x should also be pushed. We
do not do this now, so the effect of (x <= 0) is not propagated further. 
Algo for point 2: 
a> add (x<=0) as decision in to the implication graph, instead of cond 
b> update the worklist based on cond (lhs), as well as (x<=0) (rhs). Normally
we update worklist based on lhs only, but for cond statements we update 
worklist based on lhs and rhs as well 

4> For the negation of  (cond == (x <= 0)), do the following:
a> Add !(x<=0) in to the implication graph.  
b> update the worklist based on cond (lhs), as well as (x<=0) (rhs).
   but for cond statements we update worklist based on lhs and rhs as well 

Discussion:
1> For the negation of  (cond == (x <= 0)), do the following:
   a> Add !(cond) in to the implication graph.  

2> Make the decision heuristic structured:
    init() -- function in acdl_solver that implements the following :
       dec_heuristic_cond.init() -- initialize the container with boolean variables
       dec_heuristic_int.init() -- initialize the container with bit-vector variables
    class dec_heuristic_all : dec_heuristic_baset
    {
      decide() {
        dec_heuristic_cond;  
        dec_heuristic_bv;  
      }
    }
3> For recursive deductions in Implication graph, when added 10->3, dont add
3->10    
4> Add learned clause to the conflict_literal container.

April 2014:
Query: 

1> Do we change (not flip but select a different variable) the present decision
when the present decision is not complete ? We always flip the present decision
when it leads to conflict.

Peter Meeting:
--------------
1> Do we make changes to the meet irreducible like !(-x<=10) in the abstract value 
temporarily for computing l and u for the splitting function or we change all
these negated meet irreduciblet permanantly in the abstract value itself ?

2> Check the implementation of computing l or u in domain.split. Specially 
creating meet_irreduciblet like (x >= -10), where I created (-10) with
mp_integer. 

3> !(ID_le) --> ID_gt, !(ID_ge) --> ID_lt

4> How to use the return value from the dominator (uip). How can I access the node_index for the UIP ? 
Look for the dominator that has the smallest target_sett and also contains the
conflict_node (false_exprt).

Meeting on 12th May 2016
------------------------
1> Do we call normalize_val only after we add a new decision to the 
implication graph so that decision splitting can be done or call normalize_val
before is_complete() function is called because we need to take into account the 
implication graph.

2> the conflict clause is constructed depending on the kind of proof
(propositional, ai, bmc).  
